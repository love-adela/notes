# 논리회로에서 음수 표현하기

논리회로에서 음수를 표현하는 방법은 여러가지가 있는데, 그중에서 MSB의 값 (0 또는 1)에 따라 양수/음수를 표현하는 방법을 알아보자.

각 표현 방식은 아래와 같은 장단점이 있고, 이중에서 가장 많이 쓰이는 부호 표현 방식은 two's complement다. 회로가 가장 간단하게 구성되기 때문에 비용을 줄일 수 있다.

## 1. 부호 절대값 (Sign-Magnitude)

1.1 구성

- 부호 : MSB(Most Significant Bit)
   - 0이면 양수, 1이면 음수
- 절대값 : 나머지 비트

1.2 문제점

- `0`이 `+0`과 `-0`으로 존재해서 둘 다 0으로 인식하도록 별도의 연산을 수행해야 한다.
- 덧셈 구현할 때 : 부호와 절대값을 따로 분리해서 계산해야 한다.
  - 음수를 더하면 음의 부호가 붙지만 값은 절대값끼리의 합이 된다.
- 뺄셈 구현할 때 : 절대값이 큰 수에서 작은 수를 빼야 함. 그 반대의 경우에는 순서를 바꿔서 구현해야 하지만, 이를 회로로 만들기는 어렵다.
  - 음수를 더하는 방식으로는 뺄셈이 구현되지 않음. 뺄셈기를 따로 구현해야 한다.
- `<`, `>`, `<=`, `>=` 등의 비교연산을 수행할 때 모순이 생긴다.

## 2. 1의 보수 (1's Complement)

2.1 특징

- 부호 절대값 방식에서 음수일 때의 값의 순서를 반대로 두었음.
- 양수 값을 나타내는 비트를 하나씩 반전시키면 음수 값이 표현된다. 여전히 0이면 양수, 1이면 음수가 된다.
- 부호 절대값 방식처럼 부호와 절대값을 따로 계산하지 않고, 음수를 더함으로써 뺄셈을 할 수 있게 된다. 덧셈, 뺄셈 모두 간편해진다.
- 캐리가 발생하면 LSB(Least Significant Bit)에 1을 더해줘야 한다. 
- 부호 절대값 방식에서 발생했던 음수의 비교연산 모순이 일어나지 않는다.

2.2 문제점

- `0`이 `+0`과 `-0`으로 존재해서 둘 다 0으로 인식하도록 별도의 연산을 수행해야 한다.
  - 4bit 일 때, 0000과 1111 모두 0으로 처리해야 한다. 
  - 캐리가 발생되었는지 확인하기 위해 LSB에 1을 더해주는 회로를 따로 구성해야 한다.

## 3. 2의 보수 (2's Complement)

3.1 특징

- `-0` 대신 -8을 도입한다. 따라서 1의 보수에서 생겼던 `-0` 이 사라지고 캐리를 따로 처리해야 하지 않아도 된다.
  - 수학적인 일관성을 보장한다.
- 덧셈, 뺄셈 모두 덧셈기로만 연산이 가능해 회로가 간단해진다.
  - 캐리를 따로 처리하지 않는다.
- 부호를 신경쓰지 않고 곱셈 연산을 할 수 있다.


3.2 부호를 표시하는 방법

- MSB가 0이면 양수, 1이면 음수
- 부호를 바꾸려면 비트를 하나씩 반전해서 LSB에 1을 더한다.

3.3 Modulo 연산에 따른 순환군

- 예를 들어 4비트 정수는 A={0, 1, 2,3,4,5,6,7,8,9,10,11,12,13,14,15}가 있는 `mod 2^4`를 한 집합으로 볼 수 있다.
  - 정수 x, y에 대해 성립하던 덧셈/뺄셈에 관련된 수학적 성질이 `x mod 2^4`, `y mod 2^4`에 대해서도 성립한다. 
  - `x= 24`, `y=20`, `x-y=4`가 4비트 정수에서도 성립하는지 알아보자. 
    - `24 mod 2^4 = 8`
    - `20 mod 2^4 = 4`
  
    이렇게 x, y에 대한 modulo 값으로 연산하여 연산에 대한 결과값을 집합 A안에서 찾을 수 있다.

3.4 한계

- 순환군에 의해 나눗셈을 정의하면 원치 않는 값이 나오기도 한다. 오버플로우가 발생. 따라서 나눗셈의 경우에는 예외처리를 한다.
  - *오버플로우 : 모듈로를 취하지 않았을 때 값을 찾을 수 없는 현상*
